diff --git a/mlapronidl/lincons0.idl b/mlapronidl/lincons0.idl
index b58119c..19b4a4a 100644
--- a/mlapronidl/lincons0.idl
+++ b/mlapronidl/lincons0.idl
@@ -60,14 +60,65 @@ let string_of_typ = function\n\
 | SUP -> \">\"\n\
 | DISEQ -> \"<>\"\n\
 \n\
-let print assoc fmt cons = \n\
-  Linexpr0.print assoc fmt cons.linexpr0;\n\
-  Format.fprintf fmt \"%s0\" (string_of_typ cons.typ);\n\
-  begin match cons.typ with\n\
-  | EQMOD x -> Format.fprintf fmt \" mod %a\" Scalar.print x;\n\
-  | _ -> ()\n\
-  end;\n\
-  ()\n\
+let print assoc fmt cons =							    \n\
+  let revcmp = function								    \n\
+    | SUPEQ -> \"<=\"								    \n\
+    | SUP -> \"<\"								    \n\
+    | (EQ | EQMOD _) -> \"=\"							    \n\
+    | DISEQ -> \"<>\"								    \n\
+  in										    \n\
+  let print_coeff fmt = function						    \n\
+    | Coeff.Scalar scalar ->							    \n\
+        if Scalar.equal_int scalar (-1) then					    \n\
+          Format.pp_print_string fmt \"-\"					    \n\
+        else if not (Scalar.equal_int scalar 1) then				    \n\
+          Scalar.print fmt scalar;						    \n\
+    | Coeff.Interval i ->							    \n\
+        Interval.print fmt i							    \n\
+  in										    \n\
+  let sgn_of_coeff c = match Coeff.reduce c with				    \n\
+    | Coeff.Scalar x -> Scalar.sgn x						    \n\
+    | Coeff.Interval i -> if Interval.is_zero i then 0 else 1			    \n\
+  in										    \n\
+  let sz = ref 0 in								    \n\
+  Linexpr0.iter									    \n\
+    (fun coeff _ -> if sgn_of_coeff coeff <> 0 then sz := succ !sz)		    \n\
+    cons.linexpr0;								    \n\
+  if !sz == 1 then								    \n\
+    let cst = Linexpr0.get_cst cons.linexpr0 in					    \n\
+    Linexpr0.iter begin fun coeff dim ->					    \n\
+      if sgn_of_coeff coeff <> 0 then						    \n\
+        let c, op, cst =							    \n\
+          if sgn_of_coeff coeff > 0 then					    \n\
+            coeff, string_of_typ cons.typ, Coeff.neg cst			    \n\
+          else									    \n\
+            let neg_coeff = Coeff.neg coeff in					    \n\
+            let revop = revcmp cons.typ in					    \n\
+            let mpz = Mpz.init () in						    \n\
+            match cons.typ, cst with						    \n\
+              | (SUP|SUPEQ), Coeff.Scalar (Scalar.Float c)			    \n\
+                    when float_of_int (truncate c) = c ->    (* integer const. *)   \n\
+                  neg_coeff, revop, Coeff.s_of_int (truncate c)			    \n\
+              | (SUP|SUPEQ), Coeff.Scalar (Scalar.Mpqf c)    (* ibid. *)	    \n\
+                    when (Mpq.get_den mpz (Mpqf._mpq c); Mpz.cmp_si mpz 1 = 0) ->   \n\
+                  Mpq.get_num mpz (Mpqf._mpq c);				    \n\
+                  neg_coeff, revop, Coeff.s_of_mpq (Mpq.of_mpz mpz)		    \n\
+              | _ ->								    \n\
+                  neg_coeff, revop, cst						    \n\
+        in									    \n\
+        Format.fprintf fmt \"%a%s%s%a\" print_coeff c				    \n\
+          (assoc dim) op Coeff.print cst					    \n\
+    end cons.linexpr0								    \n\
+  else										    \n\
+    begin									    \n\
+      Linexpr0.print assoc fmt cons.linexpr0;					    \n\
+      Format.fprintf fmt \"%s0\" (string_of_typ cons.typ);			    \n\
+    end;									    \n\
+  begin match cons.typ with							    \n\
+    | EQMOD x -> Format.fprintf fmt \" mod %a\" Scalar.print x;			    \n\
+    | _ -> ()									    \n\
+  end;										    \n\
+  ()										    \n\
 let make expr typ = {\n\
 linexpr0 = expr; typ = typ \n\
 }\n\
diff --git a/opam/files/lincons-basic-readability.patch b/opam/files/lincons-basic-readability.patch
index ec08589..e69de29 100644
--- a/opam/files/lincons-basic-readability.patch
+++ b/opam/files/lincons-basic-readability.patch
@@ -1,81 +0,0 @@
-diff --git a/mlapronidl/lincons0.idl b/mlapronidl/lincons0.idl
-index b58119c..e49cf79 100644
---- a/mlapronidl/lincons0.idl
-+++ b/mlapronidl/lincons0.idl
-@@ -60,14 +60,68 @@ let string_of_typ = function\n\
- | SUP -> \">\"\n\
- | DISEQ -> \"<>\"\n\
- \n\
--let print assoc fmt cons = \n\
--  Linexpr0.print assoc fmt cons.linexpr0;\n\
--  Format.fprintf fmt \"%s0\" (string_of_typ cons.typ);\n\
--  begin match cons.typ with\n\
--  | EQMOD x -> Format.fprintf fmt \" mod %a\" Scalar.print x;\n\
--  | _ -> ()\n\
--  end;\n\
--  ()\n\
-+let print assoc fmt cons =							    \n\
-+  let revcmp = function								    \n\
-+    | SUPEQ -> \"<=\"								    \n\
-+    | SUP -> \"<\"								    \n\
-+    | (EQ | EQMOD _) -> \"=\"							    \n\
-+    | DISEQ -> \"<>\"								    \n\
-+  in										    \n\
-+  let print_coeff fmt = function						    \n\
-+    | Coeff.Scalar scalar ->							    \n\
-+        if Scalar.equal_int scalar (-1) then					    \n\
-+          Format.pp_print_string fmt \"-\"					    \n\
-+        else if not (Scalar.equal_int scalar 1) then				    \n\
-+          Scalar.print fmt scalar;						    \n\
-+    | Coeff.Interval i ->							    \n\
-+        Interval.print fmt i							    \n\
-+  in										    \n\
-+  let sgn_of_coeff c = match Coeff.reduce c with				    \n\
-+    | Coeff.Scalar x -> Scalar.sgn x						    \n\
-+    | Coeff.Interval i -> if Interval.is_zero i then 0 else 1			    \n\
-+  in										    \n\
-+  let sz = ref 0 in								    \n\
-+  Linexpr0.iter									    \n\
-+    (fun coeff _ -> if sgn_of_coeff coeff <> 0 then sz := succ !sz)			    \n\
-+    cons.linexpr0;								    \n\
-+  if !sz == 1 then								    \n\
-+    let cst = Linexpr0.get_cst cons.linexpr0 in					    \n\
-+    Linexpr0.iter begin fun coeff dim ->						    \n\
-+      if sgn_of_coeff coeff <> 0 then						    \n\
-+        let c, op, cst =							    \n\
-+          if sgn_of_coeff coeff > 0 then					    \n\
-+            coeff, string_of_typ cons.typ, Coeff.neg cst			    \n\
-+          else									    \n\
-+            let neg_coeff = Coeff.neg coeff in					    \n\
-+            let mpz = Mpz.init () in						    \n\
-+            match cons.typ, cst with						    \n\
-+              | SUPEQ, Coeff.Scalar (Scalar.Float c)				    \n\
-+                    when float_of_int (truncate c) = c ->    (* integer coeff. *)    \n\
-+                  neg_coeff, \"<\", Coeff.s_of_int (truncate c + 1)		    \n\
-+              | SUPEQ, Coeff.Scalar (Scalar.Mpqf c)				    \n\
-+                    (* when Mpzf.cmp_int (Mpqf.get_den c) 1 = 0 -> *)		    \n\
-+                    when (Mpq.get_den mpz (Mpqf._mpq c); Mpz.cmp_si mpz 1 = 0) ->    \n\
-+                  Mpq.get_num mpz (Mpqf._mpq c);				    \n\
-+                  (* let c = Mpqf.of_mpz (Mpqf.get_num c) in *)			    \n\
-+                  (* let one = Mpq.of_int 1 in *)				    \n\
-+                  Mpz.add_ui mpz mpz 1;                (* XXX really allowed? *)    \n\
-+                  neg_coeff, \"<\", Coeff.s_of_mpq (Mpq.of_mpz mpz)		    \n\
-+              | _ ->								    \n\
-+                  neg_coeff, revcmp cons.typ, cst				    \n\
-+        in									    \n\
-+        Format.fprintf fmt \"%a%s%s%a\" print_coeff c				    \n\
-+          (assoc dim) op Coeff.print cst					    \n\
-+    end cons.linexpr0								    \n\
-+  else										    \n\
-+    begin									    \n\
-+      Linexpr0.print assoc fmt cons.linexpr0;					    \n\
-+      Format.fprintf fmt \"%s0\" (string_of_typ cons.typ);			    \n\
-+    end;									    \n\
-+  begin match cons.typ with							    \n\
-+    | EQMOD x -> Format.fprintf fmt \" mod %a\" Scalar.print x;			    \n\
-+    | _ -> ()									    \n\
-+  end;										    \n\
-+  ()										    \n\
- let make expr typ = {\n\
- linexpr0 = expr; typ = typ \n\
- }\n\
